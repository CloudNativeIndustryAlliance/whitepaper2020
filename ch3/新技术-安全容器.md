---
authors: ["linjinbao666"]
company: ["数澜科技"]
reviewers: [""]
---

# 安全容器

本文从介绍3种容器常见的安全问题，以及应对措施。

## 背景

作为容器技术的实时标准，Kubernetes在流行的同时，也面临着很多安全性的挑战。包括但不限于以下几种：

* root用户的Dockerfile引起的权限问题

* 挂载出来的文件系统权限过高的问题

* 网络隔离策略的问题

## root用户的Dockerfile引起的权限问题

该问题是最为常见的安全问题，由于Dockerfile的书写问题引起，请看如下Dockerfile：

```code

FROM ubuntu:latest
RUN apt update && apt install -y make
COPY app /app
EXPOSE 8080
CMD /app

```

上面的Dockerfile表面上看起来没有问题，但是实际上却使用了默认的`root`用户，以该镜像运行的容器，其容器中的程序会以root权限运行任何命令，这会给容器造成不可预计的风险，且该风险可能波及到其他和其网络相通的容器。
修改后的Dockerfile为：
```code

FROM ubuntu:latest
RUN apt update && apt install -y make
COPY app /app
# 创建一个新的用户（user1）和新的组（group1）；然后切换到该用户的上下文中。
RUN useradd user1 && groupadd group1
USER user1:group1
EXPOSE 8080
CMD /app

```

* 挂载出来的文件系统权限过高的问题

Kubernetes的声明文件允许定义容器的挂载，请看如下的一个声明文件：

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: web
    name: web
  spec:
    selector:
      matchLabels:
        app: web
    template:
      metadata:
        labels:
          app: web
          name: web
      spec:
        containers:
        - command: ["sleep"]
          args: ["999"]
          image: ubuntu:latest
          name: web
          volumeMounts:
            - mountPath: /writeable/location/here #创建一个可写卷
              name: volName
        volumes:
        - emptyDir: {}
          name: volName

```

该声明文件创建了一个emptyDir模式的存储卷，且在容器`web`中进行了挂载操作，该操作并未制定容器对该目录的所有权限，即容器可以任意的写入文件到该目录，可能引起磁盘写满等问题。正确的操作是加上限定，例如：
```yaml

...
name: web
securityContext:
  readOnlyRootFilesystem: true #使容器的文件系统成为只读
volumeMounts:
  - mountPath: /writeable/location/here #创建一个可写卷
    name: volName

```
或者：
```yaml

...
name: web
volumeMounts:
  - mountPath: /writeable/location/here #创建一个可写卷
    name: volName
    readOnly: true  # 限定之都权限

```

* 网络隔离策略的问题

Kubernetes集群默认没有限定网络，其所有namespace下的容器是网络互通的，该隐患会导致恶意容器破坏整个集群的其他容器。针对该问题，我们需要使用网络策略来隔离不同的名称空间。实例如下：

```yaml

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: access-nginx
  namespace: prod #这可以是任何一个命名空间，或者在不使用命名空间的情况下省略。
spec:
  podSelector:
    matchLabels:
      app: nginx
  ingress:
    - from:
      - podSelector:
        matchLabels:
          access: "true"

```

以上策略限制了只有携带标签`access:true`的pod可以访问`nginx`服务。